* lsoda: C++ header library for ordinary differential equations

** Summary

- This R package provides a C++ header file for using the ~lsoda~ function from ~ODEPACK~. This package fills a gap to allow ~LSODA::ode()~ to be called from C++ in other packages.
- We provide an example R function ~lsoda::ode()~, which is similar to ~deSolve::lsoda()~. The former function implements the update of the state vector ~y~ and allows for calculated values, but does not implement events. This function is a proof-of-principle and there is no reason to prefer this function to the one from ~deSolve~.
- Signatures for ~LSODA::ode()~:

#+begin_src Cpp :exports code :eval no
  typedef void (*LSODA_ODE_SYSTEM_TYPE)(double t, double *y, double *dydt, void *);
  
  Rcpp::NumericMatrix ode(std::vector<double> y,
			  std::vector<double> times,
			  LSODA_ODE_SYSTEM_TYPE func,
			  size_t nout = 0, // default value => y.size()
			  void* data = (void*) nullptr,
			  double rtol=1e-6, double atol = 1e-6);
  
  template<class Functor>
  Rcpp::NumericMatrix ode(std::vector<double> y,
			  std::vector<double> times,
			  Functor functor,
			  double rtol=1e-6, double atol = 1e-6)
#+end_src

- For the second signature, the functor takes the signature ~std::vector<double>(double,std::vector<double>)~. The functor could be a class or a function. In the following examples, we also show an example using Armadillo.
- Note: The C++ version of ~lsoda~ is a different version to the Fortran code  used in ~deSolve~ and ~scipy~. The differences are minor.


** Installation

- Install the R package from GitHub. I will shortly submit this to CRAN.

#+begin_src R :session *R* :exports code :eval no
  devtools::install_github("mclements/lsoda")
#+end_src


** Examples

*** Set-up

- We will use the ~Rcpp~, ~lsoda~ and ~deSolve~ packages.
- For the examples, we will use specific times and initial values.
- We first show how to call the ordinary differential equation solver from R and compare the results with those from ~deSolve::lsoda()~. 

#+begin_src R :session *R* :results output :exports both :eval yes
  library(Rcpp)
  library(lsoda)
  library(deSolve)
  times = c(0,0.4*10^(0:10))
  y = c(1,0,0)
  func = function(t,y,...) {
      ydot = rep(0,3)
      ydot[1] = 1.0E4 * y[2] * y[3] - .04E0 * y[1]
      ydot[3] = 3.0E7 * y[2] * y[2]
      ydot[2] = -1.0 * (ydot[1] + ydot[3])
      list(ydot, sum(y))
  }
  lsoda1 = lsoda::ode(y,times,func, rtol=1e-8, atol=1e-8)
  deSolve1 = deSolve::ode(y,times, func, rtol=1e-8, atol=1e-8)
  range(lsoda1 - deSolve1)
#+end_src

#+RESULTS:
: [1] -7.533720e-08  7.532629e-08

#+begin_src R :session *R* :results output :exports both :eval no
  library(microbenchmark)
  microbenchmark(lsoda::ode(y,times,func))
  microbenchmark(deSolve::ode(y,times,func))
#+end_src

#+RESULTS:
: Unit: milliseconds
:                        expr      min       lq     mean   median       uq      max neval
:  lsoda::ode(y, times, func) 3.030573 3.066783 3.256843 3.100018 3.189049 5.937372   100
: Unit: milliseconds
:                          expr      min       lq     mean   median       uq      max neval
:  deSolve::ode(y, times, func) 2.969679 3.067279 3.284607 3.124838 3.522614 5.287864   100

*** Example: historical C interface with ~(void*) data~

#+begin_src R :session *R* :results output :exports both :eval no
  sourceCpp(code="
  // [[Rcpp::depends(lsoda)]]
  #include \"lsoda.h\"
  void fex(double t, double*  y, double* ydot, void* data) {
    ydot[0] = 1.0E4 * y[1] * y[2] - .04E0 * y[0];
    ydot[2] = 3.0E7 * y[1] * y[1];
    ydot[1] = -1.0 * (ydot[0] + ydot[2]);
    ydot[3] = y[0]+y[1]+y[2];
  }
  // [[Rcpp::export]]
  Rcpp::NumericMatrix test_lsoda_1(std::vector<double> y, std::vector<double> times) {
    return LSODA::ode(y, times, fex, 4, (void*) nullptr, 1e-12, 1e-12);
  }")
  test_lsoda_1(y,times) |> print(digits=12)
#+end_src

#+RESULTS:
#+begin_example
       time                y1                y2              y3 res1
 [1,] 0e+00 1.00000000000e+00 0.00000000000e+00 0.0000000000000    1
 [2,] 4e-01 9.85172113866e-01 3.38639537906e-05 0.0147940221806    1
 [3,] 4e+00 9.05518678607e-01 2.24047568782e-05 0.0944589166360    1
 [4,] 4e+01 7.15827068759e-01 9.18553476609e-06 0.2841637457064    1
 [5,] 4e+02 4.50518668519e-01 3.22290144228e-06 0.5494781085800    1
 [6,] 4e+03 1.83202257815e-01 8.94237125505e-07 0.8167968479480    1
 [7,] 4e+04 3.89833771094e-02 1.62176831695e-07 0.9610164607137    1
 [8,] 4e+05 4.93827453625e-03 1.98499409412e-08 0.9950617056138    1
 [9,] 4e+06 5.16809611427e-04 2.06829453100e-09 0.9994831883203    1
[10,] 4e+07 5.20307254746e-05 2.08133601326e-10 0.9999479690664    1
[11,] 4e+08 5.20770650266e-06 2.08309331907e-11 0.9999947922727    1
[12,] 4e+09 5.20830345857e-07 2.08332245547e-12 0.9999994791676    1
#+end_example

*** Example: Using a functor class

#+begin_src R :session *R* :results output :exports both :eval no
  sourceCpp(code="
  // [[Rcpp::depends(lsoda)]]
  #include \"lsoda.h\"
  class Functor {
  public:
  Functor() {}
    std::vector<double> operator()(double t, std::vector<double> y) {
      std::vector<double> ydot(4);
      ydot[0] = 1.0E4 * y[1] * y[2] - .04E0 * y[0];
      ydot[2] = 3.0E7 * y[1] * y[1];
      ydot[1] = -1.0 * (ydot[0] + ydot[2]);
      ydot[3] = y[0]+y[1]+y[2];
      return ydot;
    }
  };
  // [[Rcpp::export]]
  Rcpp::NumericMatrix test_lsoda_3(std::vector<double> y, std::vector<double> times) {
    Functor functor;
    return LSODA::ode(y, times, functor, 1.0e-10, 1.0e-10);
  }")
  test_lsoda_3(c(1,0,0),times) |> print(digits=12)
#+end_src

#+RESULTS:
#+begin_example
       time                y1                y2              y3 res1
 [1,] 0e+00 1.00000000000e+00 0.00000000000e+00 0.0000000000000    1
 [2,] 4e-01 9.85172113672e-01 3.38639537739e-05 0.0147940223743    1
 [3,] 4e+00 9.05518679079e-01 2.24047552531e-05 0.0944589161661    1
 [4,] 4e+01 7.15827068870e-01 9.18553476964e-06 0.2841637455955    1
 [5,] 4e+02 4.50518669112e-01 3.22290144442e-06 0.5494781079864    1
 [6,] 4e+03 1.83202258168e-01 8.94237128627e-07 0.8167968475946    1
 [7,] 4e+04 3.89833778291e-02 1.62176885438e-07 0.9610164599940    1
 [8,] 4e+05 4.93827517223e-03 1.98499435115e-08 0.9950617049778    1
 [9,] 4e+06 5.16810038376e-04 2.06829624776e-09 0.9994831878933    1
[10,] 4e+07 5.20309783106e-05 2.08134611828e-10 0.9999479688136    1
[11,] 4e+08 5.20788109363e-06 2.08316315628e-11 0.9999947920981    1
[12,] 4e+09 5.20943309073e-07 2.08377430884e-12 0.9999994790546    1
#+end_example


*** Example: Using a lambda function

- We see that we can also use a functor that is a lambda function:

#+begin_src R :session *R* :results output :exports both :eval no
  sourceCpp(code="
  // [[Rcpp::depends(lsoda)]]
  #include \"lsoda.h\"
  auto lambda = [](double t, std::vector<double> y) {
      std::vector<double> ydot(4);
      ydot[0] = 1E4 * y[1] * y[2] - .04E0 * y[0];
      ydot[2] = 3.0E7 * y[1] * y[1];
      ydot[1] = -1.0 * (ydot[0] + ydot[2]);
      ydot[3] = y[0]+y[1]+y[2];
      return ydot;
    };
  // [[Rcpp::export]]
  Rcpp::NumericMatrix test_lsoda_4(std::vector<double> y,
                                   std::vector<double> times,
                                   double rtol = 1-6, double atol = 1e-6) {
    return LSODA::ode(y, times, lambda, rtol, atol);
  }")
  test_lsoda_4(c(1,0,0),times,rtol=1e-10,atol=1e-10)
#+end_src

#+RESULTS:
#+begin_example
       time           y1           y2         y3 res1
 [1,] 0e+00 1.000000e+00 0.000000e+00 0.00000000    1
 [2,] 4e-01 9.851721e-01 3.386395e-05 0.01479402    1
 [3,] 4e+00 9.055187e-01 2.240476e-05 0.09445892    1
 [4,] 4e+01 7.158271e-01 9.185535e-06 0.28416375    1
 [5,] 4e+02 4.505187e-01 3.222901e-06 0.54947811    1
 [6,] 4e+03 1.832023e-01 8.942371e-07 0.81679685    1
 [7,] 4e+04 3.898338e-02 1.621769e-07 0.96101646    1
 [8,] 4e+05 4.938275e-03 1.984994e-08 0.99506170    1
 [9,] 4e+06 5.168100e-04 2.068296e-09 0.99948319    1
[10,] 4e+07 5.203098e-05 2.081346e-10 0.99994797    1
[11,] 4e+08 5.207881e-06 2.083163e-11 0.99999479    1
[12,] 4e+09 5.209433e-07 2.083774e-12 0.99999948    1
#+end_example

*** Using ~RcppArmadillo~

- The following example provides an ~ode()~ implementation that uses Armadillo vectors.
- The signature is:
  
#+begin_src R :session *R* :results output :exports both :eval no
  template<class Functor>
  Rcpp::NumericMatrix ode(arma::vec y,
			  arma::vec times,
			  Functor functor,
			  double rtol=1e-6, double atol = 1e-6);
#+end_src
- The functor has a signature ~arma::vec(double,arma::vec)~.
- We also provide an example.

#+begin_src R :session *R* :results output :exports code
  sourceCpp(code="
  // [[Rcpp::depends(lsoda)]]
  // [[Rcpp::depends(RcppArmadillo)]]
  #include \"RcppArmadillo.h\"
  #include \"lsoda.h\"
  template<class Functor>
  void lsoda_arma_adaptor(double t, double* y, double* ydot, void* data) {
    using Tuple = std::tuple<Functor*, size_t, size_t>;
    Tuple* tuple = static_cast<Tuple*>(data);
    Functor* f = std::get<0>(*tuple);
    size_t neq = std::get<1>(*tuple);
    // size_t nout = std::get<2>(*tuple);
    arma::vec yv(neq);
    std::copy(y,y+neq,yv.begin());
    arma::vec ydotv = (*f)(t,yv); // determines the functor signature
    std::copy(ydotv.begin(),ydotv.end(),ydot);
  }
  template<class Functor>
  Rcpp::NumericMatrix ode(arma::vec y,
			  arma::vec times,
			  Functor functor,
			  double rtol=1e-6, double atol = 1e-6) {
    size_t nout = functor(times[0], y).size();
    std::tuple<Functor*,size_t,size_t> tuple{&functor, y.size(), nout};
    std::vector<double> yv(y.begin(), y.end());
    std::vector<double> timesv(times.begin(), times.end());
    return LSODA::ode(yv, timesv, lsoda_arma_adaptor<Functor>, nout,
                      (void*) &tuple, rtol, atol);
  }
  auto lambda = [](double t, arma::vec y) {
      arma::vec ydot(4);
      ydot[0] = 1E4 * y[1] * y[2] - .04E0 * y[0];
      ydot[2] = 3.0E7 * y[1] * y[1];
      ydot[1] = -1.0 * (ydot[0] + ydot[2]);
      ydot[3] = arma::sum(y);
      return ydot;
    };
  // [[Rcpp::export]]
  Rcpp::NumericMatrix test_lsoda_5(arma::vec y,
                                   arma::vec times,
                                   double rtol = 1-6, double atol = 1e-6) {
    return ode(y, times, lambda, rtol, atol);
  }")
  test_lsoda_5(c(1,0,0),times,rtol=1e-12,atol=1e-12) |> print(digits=12)
#+end_src

#+RESULTS:
#+begin_example
       time                y1                y2              y3 res1
 [1,] 0e+00 1.00000000000e+00 0.00000000000e+00 0.0000000000000    1
 [2,] 4e-01 9.85172113866e-01 3.38639537906e-05 0.0147940221806    1
 [3,] 4e+00 9.05518678607e-01 2.24047568782e-05 0.0944589166360    1
 [4,] 4e+01 7.15827068759e-01 9.18553476609e-06 0.2841637457064    1
 [5,] 4e+02 4.50518668519e-01 3.22290144228e-06 0.5494781085800    1
 [6,] 4e+03 1.83202257815e-01 8.94237125505e-07 0.8167968479480    1
 [7,] 4e+04 3.89833771094e-02 1.62176831695e-07 0.9610164607137    1
 [8,] 4e+05 4.93827453625e-03 1.98499409412e-08 0.9950617056138    1
 [9,] 4e+06 5.16809611427e-04 2.06829453100e-09 0.9994831883203    1
[10,] 4e+07 5.20307254746e-05 2.08133601326e-10 0.9999479690664    1
[11,] 4e+08 5.20770650266e-06 2.08309331907e-11 0.9999947922727    1
[12,] 4e+09 5.20830345857e-07 2.08332245547e-12 0.9999994791676    1
#+end_example
